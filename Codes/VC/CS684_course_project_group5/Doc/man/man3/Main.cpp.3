.TH "Main.cpp" 3 "Mon Nov 8 2010" "Version 1" "CS684_course_project_group5" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Main.cpp \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'includes.h'\fP
.br

.SS "Defines"

.in +1c
.ti -1c
.RI "#define \fBnull\fP   '\\0'"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBcapture_image\fP (char *)"
.br
.ti -1c
.RI "void \fBvectorGeneration\fP (char *, IplImage *, list< \fBpoint\fP >)"
.br
.ti -1c
.RI "void \fBsample\fP (char *, IplImage *)"
.br
.ti -1c
.RI "void \fBshow_vector_image\fP (list< \fBpoint\fP >)"
.br
.ti -1c
.RI "void \fBshow_vector_image\fP (list< \fBpoint\fP > path, char *imgfile, IplImage *img1)"
.br
.ti -1c
.RI "list< double > \fBmoveToNextEnd\fP (list< double > moves, \fBpoint\fP prev_endCur, \fBpoint\fP endCur, \fBpoint\fP startNext, \fBpoint\fP next_startNext)"
.br
.ti -1c
.RI "int \fBmain\fP ()"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "char ** \fBmat\fP"
.br
.in -1c
.SH "Define Documentation"
.PP 
.SS "#define null   '\\0'"
.PP
Definition at line 2 of file Main.cpp.
.SH "Function Documentation"
.PP 
.SS "void capture_image (char * filemane)"Capture image from webcam 
.PP
Definition at line 54 of file Main.cpp.
.PP
.nf
{
        IplImage* frame = 0;            
        //CV_CAP_ANY
        CvCapture* capture = cvCaptureFromCAM( 1 );   
        if( !capture ) 
        {     
                fprintf( stderr, 'ERROR: capture is NULL \n' );     
                return;   
        }    
        // Create a window in which the captured images will be presented   
        cvNamedWindow( 'mywindow', CV_WINDOW_AUTOSIZE );    
        // Show the image captured from the camera in the window and repeat   
        while( 1 ) 
        {     
                // Get one frame     
                frame = cvQueryFrame( capture );     
                if( !frame ) 
                {       
                        fprintf( stderr, 'ERROR: frame is null...\n' );
                        return;
                }      
                cvShowImage( 'mywindow', frame );                               
                // Do not release the frame     
                //If ESC key pressed, Key=0x10001B under OpenCV 0.9.7(linux version),     
                //remove higher bits using AND operator     
                if( (cvWaitKey(10) & 255) == 27 ) 
                {
                        break;   
                }
        }    
        // Show the image frame.
        cvShowImage( 'mywindow', frame );
        cvWaitKey(0);
        // Save the image in specified filename
        if(!cvSaveImage(filemane,frame)) printf('Could not save: %s\n',filemane);
        // Release the capture device and window
        cvReleaseCapture( &capture );
        cvDestroyWindow( 'mywindow' ); 
}
.fi
.SS "int main ()"
.PP
Definition at line 309 of file Main.cpp.
.PP
.nf
{
        IplImage* img=0;
        char* filename = 'face2.jpg';
        capture_image(filename);
        sample(filename,img);

        getchar();
        return 0;
}
.fi
.SS "list<double> moveToNextEnd (list< double > moves, \fBpoint\fP prev_endCur, \fBpoint\fP endCur, \fBpoint\fP startNext, \fBpoint\fP next_startNext)"Moves the BOT to the next end point 
.PP
Definition at line 100 of file Main.cpp.
.PP
.nf
                                                                                                                      {

        double angle1,angle2,angle3;
        angle1=endCur.angleBetweenPoints(prev_endCur);
        angle2=startNext.angleBetweenPoints(endCur);
        angle3=next_startNext.angleBetweenPoints(startNext);

        double dif_angle=angle2-angle3;
        if(dif_angle>180)
                dif_angle-=360;
        else if(dif_angle<-180)
                dif_angle+=360;
        
        if(((angle3/10)*(angle2/10))<0)
                dif_angle=-dif_angle;

        int TURN = (dif_angle) < 0 ? 0 : 1;

        //push in reverse order
        moves.push_front(TURN);
        moves.push_front(fabs(dif_angle));

        dif_angle=angle1-angle2;
        if(dif_angle>180)
                dif_angle-=360;
        else if(dif_angle<-180)
                dif_angle+=360;

        if(((angle1/10)*(angle2/10))<0)
                dif_angle=-dif_angle;

        TURN = (dif_angle) < 0 ? 0 : 1;
        double distance=endCur.distance(startNext);

        moves.push_front(distance);

        moves.push_front(2);
        moves.push_front(0);
        moves.push_front(0);

        moves.push_front(TURN);
        moves.push_front(fabs(dif_angle));

        return moves;
}
.fi
.SS "void sample (char * imgfile, IplImage * img)"
.PP
Apply median filter to smooth
.PP
Red boundary detection make all pixles which are outside the red boundary white.
.PP
Thresholding according to grey scale
.PP
Thinning the thresholded image
.PP
Generate vectors and do further processing
.PP
Definition at line 234 of file Main.cpp.
.PP
.nf
{
//  IplImage* img = 0; 
  int height,width,step,channels;
  char *data;
  int i;

  // load an image  
  img=cvLoadImage(imgfile);
  if(!img)
  {
    printf('Could not load image file: %s\n',imgfile);
    exit(0);
  }

  // get the image data
  height    = img->height;
  width     = img->width;
  step      = img->widthStep;
  channels  = img->nChannels;
  data      = img->imageData;

  //defining global variables 
  h=height;
  w=width;

  printf('Processing a %dx%d image with %d channels\n',height,width,channels); 
  cout<<'\n\n height '<<height<<'\nwidth '<<width<<'\nwidthStep '<<step<<'\nChannel '<<channels;

  // create a window
  cvNamedWindow('mainWin', CV_WINDOW_AUTOSIZE); 
  cvMoveWindow('mainWin', 100, 100);

  mat=new char*[height+1];
        for(i=0;i<height+1;i++)
                mat[i]=new char[width+1];

  cvSmooth(img,img,CV_MEDIAN);// display ('mainWinSmooth',img);
  
  BoundaryDetection(img,140,60,60);

  Thresholding(img,100);//   display ('mainWinThes', img );

  Thinning(img,mat);// 
  display('mainWinThinned', img );


  list<point> endPoints = StartPoints(img,mat);

  vectorGeneration(imgfile, img, endPoints);

  //release all resouces that were taken
  cvReleaseImage(&img );
}
.fi
.SS "void show_vector_image (list< \fBpoint\fP >)"
.SS "void show_vector_image (list< \fBpoint\fP > path, char * imgfile, IplImage * img1)"Show the vector image drawm 
.PP
Definition at line 19 of file Main.cpp.
.PP
.nf
{

        cout << 'Showing vector image\n';
        IplImage* img=cvLoadImage(imgfile);
        
        if (img==0)
        {
                cout << 'Can not open output file to show extracted vector image\n';
                return;
        }

        list<point>::iterator it = path.begin();
        point prev_point = (*it);
        it++;
        for (;it!=path.end();it++)
        {
                cvLine(img, cvPoint((*it).get_Y(),(*it).get_X()), cvPoint(prev_point.get_Y(),prev_point.get_X()), cvScalar(0,255,0), 4);
                cvCircle (img,cvPoint((*it).get_Y(),(*it).get_X()),1,cvScalar (255,0,0),2);
                cvCircle (img,cvPoint(prev_point.get_Y(),prev_point.get_X()),1,cvScalar (255,0,0),2);

                cvLine(img1, cvPoint((*it).get_Y(),(*it).get_X()), cvPoint(prev_point.get_Y(),prev_point.get_X()), cvScalar(0,255,0), 4);
                cvCircle (img1,cvPoint((*it).get_Y(),(*it).get_X()),1,cvScalar (255,0,0),2);
                cvCircle (img1,cvPoint(prev_point.get_Y(),prev_point.get_X()),1,cvScalar (255,0,0),2);

                prev_point = *it;
        }
        //display('mainWin', img );
        display('mainWin2', img1 );
        cvReleaseImage(&img );
}
.fi
.SS "void vectorGeneration (char * filename, IplImage * img, list< \fBpoint\fP > endPoints)"Generates vectors from the image 
.PP
Definition at line 149 of file Main.cpp.
.PP
.nf
                                                                           {
        list<point> path;
        list<point> refined_path;
        unsigned int size=endPoints.size();
        list<double> whole_moves;
        point lastPoint=point(-1,-1);
        point lastlastPoint,frontNext;

        while(endPoints.empty()==false)
        {


                point start_point=endPoints.front();
                endPoints.pop_front();
                path = traverse_black_line(mat,start_point);
                endPoints.remove (path.back());
                
                if(path.size()==1)
                        continue;


                refined_path = appriximate_straight_line(path,8);
                //cout << '\n\n\n 2nd refine \n\n';
                refined_path = appriximate_straight_line(refined_path,1);
                //create_refined_file (refined_path);
                if (refined_path.size()<=1)
                        continue;

                show_vector_image(refined_path,filename,img);
                size=endPoints.size();
                //cout<<' \n\n\n Size of list'<<size;
                list<double> moves=find_direction_vector(refined_path);

                frontNext=refined_path.front();
                refined_path.pop_front();
                refined_path.push_front(frontNext);

                if(lastPoint.get_X()!=-1)
                        moves=moveToNextEnd(moves, lastlastPoint, lastPoint, frontNext, refined_path.front());

                lastPoint=point(refined_path.back());

                refined_path.pop_back();
                lastlastPoint=refined_path.back();

                if(moves.size()==0)
                        continue;


                list<double>::iterator it;
                it=moves.begin();

                int i;
                for(i=0;it!=moves.end();it++,i++)
                {
                        whole_moves.push_back ((int)(*it));
                }
                
        }

                int *moves_int=new int[whole_moves.size()];

                list<double>::iterator it;
                it=whole_moves.begin();

                int i;
                for(i=0;it!=whole_moves.end();it++,i++)
                {
                        moves_int[i]=(int)(*it);
                        cout<<'\n ';
                        if (i%3==0)
                                cout << 'DIST ';
                        else if (i%3==1)
                                cout <<'ANGLE ';
                        else if (i%3==2)
                                cout <<'DIRECTION ';
                        cout<<moves_int[i];
                }
                
                whole_moves.push_back(0);
                whole_moves.push_back(2);
                writeOnBot(moves_int,whole_moves.size());

}
.fi
.SH "Variable Documentation"
.PP 
.SS "char** \fBmat\fP"Global variable to maintain the image matrix 
.PP
Definition at line 8 of file Main.cpp.
.SH "Author"
.PP 
Generated automatically by Doxygen for CS684_course_project_group5 from the source code.
